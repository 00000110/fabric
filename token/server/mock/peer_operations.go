// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/common/policies"
	"github.com/hyperledger/fabric/core/chaincode/platforms"
	"github.com/hyperledger/fabric/core/committer/txvalidator/plugin"
	"github.com/hyperledger/fabric/core/committer/txvalidator/v20/plugindispatcher"
	"github.com/hyperledger/fabric/core/common/sysccprovider"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
)

type PeerOperations struct {
	CreateChainFromBlockStub        func(cb *common.Block, sccp sysccprovider.SystemChaincodeProvider, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, lr, nr plugindispatcher.LifecycleResources) error
	createChainFromBlockMutex       sync.RWMutex
	createChainFromBlockArgsForCall []struct {
		cb                     *common.Block
		sccp                   sysccprovider.SystemChaincodeProvider
		deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider
		lr                     plugindispatcher.LifecycleResources
		nr                     plugindispatcher.LifecycleResources
	}
	createChainFromBlockReturns struct {
		result1 error
	}
	createChainFromBlockReturnsOnCall map[int]struct {
		result1 error
	}
	GetChannelConfigStub        func(cid string) channelconfig.Resources
	getChannelConfigMutex       sync.RWMutex
	getChannelConfigArgsForCall []struct {
		cid string
	}
	getChannelConfigReturns struct {
		result1 channelconfig.Resources
	}
	getChannelConfigReturnsOnCall map[int]struct {
		result1 channelconfig.Resources
	}
	GetChannelsInfoStub        func() []*pb.ChannelInfo
	getChannelsInfoMutex       sync.RWMutex
	getChannelsInfoArgsForCall []struct{}
	getChannelsInfoReturns     struct {
		result1 []*pb.ChannelInfo
	}
	getChannelsInfoReturnsOnCall map[int]struct {
		result1 []*pb.ChannelInfo
	}
	GetStableChannelConfigStub        func(cid string) channelconfig.Resources
	getStableChannelConfigMutex       sync.RWMutex
	getStableChannelConfigArgsForCall []struct {
		cid string
	}
	getStableChannelConfigReturns struct {
		result1 channelconfig.Resources
	}
	getStableChannelConfigReturnsOnCall map[int]struct {
		result1 channelconfig.Resources
	}
	GetCurrConfigBlockStub        func(cid string) *common.Block
	getCurrConfigBlockMutex       sync.RWMutex
	getCurrConfigBlockArgsForCall []struct {
		cid string
	}
	getCurrConfigBlockReturns struct {
		result1 *common.Block
	}
	getCurrConfigBlockReturnsOnCall map[int]struct {
		result1 *common.Block
	}
	GetLedgerStub        func(cid string) ledger.PeerLedger
	getLedgerMutex       sync.RWMutex
	getLedgerArgsForCall []struct {
		cid string
	}
	getLedgerReturns struct {
		result1 ledger.PeerLedger
	}
	getLedgerReturnsOnCall map[int]struct {
		result1 ledger.PeerLedger
	}
	GetMSPIDsStub        func(cid string) []string
	getMSPIDsMutex       sync.RWMutex
	getMSPIDsArgsForCall []struct {
		cid string
	}
	getMSPIDsReturns struct {
		result1 []string
	}
	getMSPIDsReturnsOnCall map[int]struct {
		result1 []string
	}
	GetPolicyManagerStub        func(cid string) policies.Manager
	getPolicyManagerMutex       sync.RWMutex
	getPolicyManagerArgsForCall []struct {
		cid string
	}
	getPolicyManagerReturns struct {
		result1 policies.Manager
	}
	getPolicyManagerReturnsOnCall map[int]struct {
		result1 policies.Manager
	}
	InitChainStub        func(cid string)
	initChainMutex       sync.RWMutex
	initChainArgsForCall []struct {
		cid string
	}
	InitializeStub        func(init func(string), sccp sysccprovider.SystemChaincodeProvider, pm plugin.Mapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider, lr, nr plugindispatcher.LifecycleResources)
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct {
		init                   func(string)
		sccp                   sysccprovider.SystemChaincodeProvider
		pm                     plugin.Mapper
		pr                     *platforms.Registry
		deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider
		membershipProvider     ledger.MembershipInfoProvider
		metricsProvider        metrics.Provider
		lr                     plugindispatcher.LifecycleResources
		nr                     plugindispatcher.LifecycleResources
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *PeerOperations) CreateChainFromBlock(cb *common.Block, sccp sysccprovider.SystemChaincodeProvider, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, lr plugindispatcher.LifecycleResources, nr plugindispatcher.LifecycleResources) error {
	fake.createChainFromBlockMutex.Lock()
	ret, specificReturn := fake.createChainFromBlockReturnsOnCall[len(fake.createChainFromBlockArgsForCall)]
	fake.createChainFromBlockArgsForCall = append(fake.createChainFromBlockArgsForCall, struct {
		cb                     *common.Block
		sccp                   sysccprovider.SystemChaincodeProvider
		deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider
		lr                     plugindispatcher.LifecycleResources
		nr                     plugindispatcher.LifecycleResources
	}{cb, sccp, deployedCCInfoProvider, lr, nr})
	fake.recordInvocation("CreateChainFromBlock", []interface{}{cb, sccp, deployedCCInfoProvider, lr, nr})
	fake.createChainFromBlockMutex.Unlock()
	if fake.CreateChainFromBlockStub != nil {
		return fake.CreateChainFromBlockStub(cb, sccp, deployedCCInfoProvider, lr, nr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createChainFromBlockReturns.result1
}

func (fake *PeerOperations) CreateChainFromBlockCallCount() int {
	fake.createChainFromBlockMutex.RLock()
	defer fake.createChainFromBlockMutex.RUnlock()
	return len(fake.createChainFromBlockArgsForCall)
}

func (fake *PeerOperations) CreateChainFromBlockArgsForCall(i int) (*common.Block, sysccprovider.SystemChaincodeProvider, ledger.DeployedChaincodeInfoProvider, plugindispatcher.LifecycleResources, plugindispatcher.LifecycleResources) {
	fake.createChainFromBlockMutex.RLock()
	defer fake.createChainFromBlockMutex.RUnlock()
	return fake.createChainFromBlockArgsForCall[i].cb, fake.createChainFromBlockArgsForCall[i].sccp, fake.createChainFromBlockArgsForCall[i].deployedCCInfoProvider, fake.createChainFromBlockArgsForCall[i].lr, fake.createChainFromBlockArgsForCall[i].nr
}

func (fake *PeerOperations) CreateChainFromBlockReturns(result1 error) {
	fake.CreateChainFromBlockStub = nil
	fake.createChainFromBlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *PeerOperations) CreateChainFromBlockReturnsOnCall(i int, result1 error) {
	fake.CreateChainFromBlockStub = nil
	if fake.createChainFromBlockReturnsOnCall == nil {
		fake.createChainFromBlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createChainFromBlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PeerOperations) GetChannelConfig(cid string) channelconfig.Resources {
	fake.getChannelConfigMutex.Lock()
	ret, specificReturn := fake.getChannelConfigReturnsOnCall[len(fake.getChannelConfigArgsForCall)]
	fake.getChannelConfigArgsForCall = append(fake.getChannelConfigArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("GetChannelConfig", []interface{}{cid})
	fake.getChannelConfigMutex.Unlock()
	if fake.GetChannelConfigStub != nil {
		return fake.GetChannelConfigStub(cid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getChannelConfigReturns.result1
}

func (fake *PeerOperations) GetChannelConfigCallCount() int {
	fake.getChannelConfigMutex.RLock()
	defer fake.getChannelConfigMutex.RUnlock()
	return len(fake.getChannelConfigArgsForCall)
}

func (fake *PeerOperations) GetChannelConfigArgsForCall(i int) string {
	fake.getChannelConfigMutex.RLock()
	defer fake.getChannelConfigMutex.RUnlock()
	return fake.getChannelConfigArgsForCall[i].cid
}

func (fake *PeerOperations) GetChannelConfigReturns(result1 channelconfig.Resources) {
	fake.GetChannelConfigStub = nil
	fake.getChannelConfigReturns = struct {
		result1 channelconfig.Resources
	}{result1}
}

func (fake *PeerOperations) GetChannelConfigReturnsOnCall(i int, result1 channelconfig.Resources) {
	fake.GetChannelConfigStub = nil
	if fake.getChannelConfigReturnsOnCall == nil {
		fake.getChannelConfigReturnsOnCall = make(map[int]struct {
			result1 channelconfig.Resources
		})
	}
	fake.getChannelConfigReturnsOnCall[i] = struct {
		result1 channelconfig.Resources
	}{result1}
}

func (fake *PeerOperations) GetChannelsInfo() []*pb.ChannelInfo {
	fake.getChannelsInfoMutex.Lock()
	ret, specificReturn := fake.getChannelsInfoReturnsOnCall[len(fake.getChannelsInfoArgsForCall)]
	fake.getChannelsInfoArgsForCall = append(fake.getChannelsInfoArgsForCall, struct{}{})
	fake.recordInvocation("GetChannelsInfo", []interface{}{})
	fake.getChannelsInfoMutex.Unlock()
	if fake.GetChannelsInfoStub != nil {
		return fake.GetChannelsInfoStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getChannelsInfoReturns.result1
}

func (fake *PeerOperations) GetChannelsInfoCallCount() int {
	fake.getChannelsInfoMutex.RLock()
	defer fake.getChannelsInfoMutex.RUnlock()
	return len(fake.getChannelsInfoArgsForCall)
}

func (fake *PeerOperations) GetChannelsInfoReturns(result1 []*pb.ChannelInfo) {
	fake.GetChannelsInfoStub = nil
	fake.getChannelsInfoReturns = struct {
		result1 []*pb.ChannelInfo
	}{result1}
}

func (fake *PeerOperations) GetChannelsInfoReturnsOnCall(i int, result1 []*pb.ChannelInfo) {
	fake.GetChannelsInfoStub = nil
	if fake.getChannelsInfoReturnsOnCall == nil {
		fake.getChannelsInfoReturnsOnCall = make(map[int]struct {
			result1 []*pb.ChannelInfo
		})
	}
	fake.getChannelsInfoReturnsOnCall[i] = struct {
		result1 []*pb.ChannelInfo
	}{result1}
}

func (fake *PeerOperations) GetStableChannelConfig(cid string) channelconfig.Resources {
	fake.getStableChannelConfigMutex.Lock()
	ret, specificReturn := fake.getStableChannelConfigReturnsOnCall[len(fake.getStableChannelConfigArgsForCall)]
	fake.getStableChannelConfigArgsForCall = append(fake.getStableChannelConfigArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("GetStableChannelConfig", []interface{}{cid})
	fake.getStableChannelConfigMutex.Unlock()
	if fake.GetStableChannelConfigStub != nil {
		return fake.GetStableChannelConfigStub(cid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getStableChannelConfigReturns.result1
}

func (fake *PeerOperations) GetStableChannelConfigCallCount() int {
	fake.getStableChannelConfigMutex.RLock()
	defer fake.getStableChannelConfigMutex.RUnlock()
	return len(fake.getStableChannelConfigArgsForCall)
}

func (fake *PeerOperations) GetStableChannelConfigArgsForCall(i int) string {
	fake.getStableChannelConfigMutex.RLock()
	defer fake.getStableChannelConfigMutex.RUnlock()
	return fake.getStableChannelConfigArgsForCall[i].cid
}

func (fake *PeerOperations) GetStableChannelConfigReturns(result1 channelconfig.Resources) {
	fake.GetStableChannelConfigStub = nil
	fake.getStableChannelConfigReturns = struct {
		result1 channelconfig.Resources
	}{result1}
}

func (fake *PeerOperations) GetStableChannelConfigReturnsOnCall(i int, result1 channelconfig.Resources) {
	fake.GetStableChannelConfigStub = nil
	if fake.getStableChannelConfigReturnsOnCall == nil {
		fake.getStableChannelConfigReturnsOnCall = make(map[int]struct {
			result1 channelconfig.Resources
		})
	}
	fake.getStableChannelConfigReturnsOnCall[i] = struct {
		result1 channelconfig.Resources
	}{result1}
}

func (fake *PeerOperations) GetCurrConfigBlock(cid string) *common.Block {
	fake.getCurrConfigBlockMutex.Lock()
	ret, specificReturn := fake.getCurrConfigBlockReturnsOnCall[len(fake.getCurrConfigBlockArgsForCall)]
	fake.getCurrConfigBlockArgsForCall = append(fake.getCurrConfigBlockArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("GetCurrConfigBlock", []interface{}{cid})
	fake.getCurrConfigBlockMutex.Unlock()
	if fake.GetCurrConfigBlockStub != nil {
		return fake.GetCurrConfigBlockStub(cid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getCurrConfigBlockReturns.result1
}

func (fake *PeerOperations) GetCurrConfigBlockCallCount() int {
	fake.getCurrConfigBlockMutex.RLock()
	defer fake.getCurrConfigBlockMutex.RUnlock()
	return len(fake.getCurrConfigBlockArgsForCall)
}

func (fake *PeerOperations) GetCurrConfigBlockArgsForCall(i int) string {
	fake.getCurrConfigBlockMutex.RLock()
	defer fake.getCurrConfigBlockMutex.RUnlock()
	return fake.getCurrConfigBlockArgsForCall[i].cid
}

func (fake *PeerOperations) GetCurrConfigBlockReturns(result1 *common.Block) {
	fake.GetCurrConfigBlockStub = nil
	fake.getCurrConfigBlockReturns = struct {
		result1 *common.Block
	}{result1}
}

func (fake *PeerOperations) GetCurrConfigBlockReturnsOnCall(i int, result1 *common.Block) {
	fake.GetCurrConfigBlockStub = nil
	if fake.getCurrConfigBlockReturnsOnCall == nil {
		fake.getCurrConfigBlockReturnsOnCall = make(map[int]struct {
			result1 *common.Block
		})
	}
	fake.getCurrConfigBlockReturnsOnCall[i] = struct {
		result1 *common.Block
	}{result1}
}

func (fake *PeerOperations) GetLedger(cid string) ledger.PeerLedger {
	fake.getLedgerMutex.Lock()
	ret, specificReturn := fake.getLedgerReturnsOnCall[len(fake.getLedgerArgsForCall)]
	fake.getLedgerArgsForCall = append(fake.getLedgerArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("GetLedger", []interface{}{cid})
	fake.getLedgerMutex.Unlock()
	if fake.GetLedgerStub != nil {
		return fake.GetLedgerStub(cid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getLedgerReturns.result1
}

func (fake *PeerOperations) GetLedgerCallCount() int {
	fake.getLedgerMutex.RLock()
	defer fake.getLedgerMutex.RUnlock()
	return len(fake.getLedgerArgsForCall)
}

func (fake *PeerOperations) GetLedgerArgsForCall(i int) string {
	fake.getLedgerMutex.RLock()
	defer fake.getLedgerMutex.RUnlock()
	return fake.getLedgerArgsForCall[i].cid
}

func (fake *PeerOperations) GetLedgerReturns(result1 ledger.PeerLedger) {
	fake.GetLedgerStub = nil
	fake.getLedgerReturns = struct {
		result1 ledger.PeerLedger
	}{result1}
}

func (fake *PeerOperations) GetLedgerReturnsOnCall(i int, result1 ledger.PeerLedger) {
	fake.GetLedgerStub = nil
	if fake.getLedgerReturnsOnCall == nil {
		fake.getLedgerReturnsOnCall = make(map[int]struct {
			result1 ledger.PeerLedger
		})
	}
	fake.getLedgerReturnsOnCall[i] = struct {
		result1 ledger.PeerLedger
	}{result1}
}

func (fake *PeerOperations) GetMSPIDs(cid string) []string {
	fake.getMSPIDsMutex.Lock()
	ret, specificReturn := fake.getMSPIDsReturnsOnCall[len(fake.getMSPIDsArgsForCall)]
	fake.getMSPIDsArgsForCall = append(fake.getMSPIDsArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("GetMSPIDs", []interface{}{cid})
	fake.getMSPIDsMutex.Unlock()
	if fake.GetMSPIDsStub != nil {
		return fake.GetMSPIDsStub(cid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getMSPIDsReturns.result1
}

func (fake *PeerOperations) GetMSPIDsCallCount() int {
	fake.getMSPIDsMutex.RLock()
	defer fake.getMSPIDsMutex.RUnlock()
	return len(fake.getMSPIDsArgsForCall)
}

func (fake *PeerOperations) GetMSPIDsArgsForCall(i int) string {
	fake.getMSPIDsMutex.RLock()
	defer fake.getMSPIDsMutex.RUnlock()
	return fake.getMSPIDsArgsForCall[i].cid
}

func (fake *PeerOperations) GetMSPIDsReturns(result1 []string) {
	fake.GetMSPIDsStub = nil
	fake.getMSPIDsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *PeerOperations) GetMSPIDsReturnsOnCall(i int, result1 []string) {
	fake.GetMSPIDsStub = nil
	if fake.getMSPIDsReturnsOnCall == nil {
		fake.getMSPIDsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getMSPIDsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *PeerOperations) GetPolicyManager(cid string) policies.Manager {
	fake.getPolicyManagerMutex.Lock()
	ret, specificReturn := fake.getPolicyManagerReturnsOnCall[len(fake.getPolicyManagerArgsForCall)]
	fake.getPolicyManagerArgsForCall = append(fake.getPolicyManagerArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("GetPolicyManager", []interface{}{cid})
	fake.getPolicyManagerMutex.Unlock()
	if fake.GetPolicyManagerStub != nil {
		return fake.GetPolicyManagerStub(cid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getPolicyManagerReturns.result1
}

func (fake *PeerOperations) GetPolicyManagerCallCount() int {
	fake.getPolicyManagerMutex.RLock()
	defer fake.getPolicyManagerMutex.RUnlock()
	return len(fake.getPolicyManagerArgsForCall)
}

func (fake *PeerOperations) GetPolicyManagerArgsForCall(i int) string {
	fake.getPolicyManagerMutex.RLock()
	defer fake.getPolicyManagerMutex.RUnlock()
	return fake.getPolicyManagerArgsForCall[i].cid
}

func (fake *PeerOperations) GetPolicyManagerReturns(result1 policies.Manager) {
	fake.GetPolicyManagerStub = nil
	fake.getPolicyManagerReturns = struct {
		result1 policies.Manager
	}{result1}
}

func (fake *PeerOperations) GetPolicyManagerReturnsOnCall(i int, result1 policies.Manager) {
	fake.GetPolicyManagerStub = nil
	if fake.getPolicyManagerReturnsOnCall == nil {
		fake.getPolicyManagerReturnsOnCall = make(map[int]struct {
			result1 policies.Manager
		})
	}
	fake.getPolicyManagerReturnsOnCall[i] = struct {
		result1 policies.Manager
	}{result1}
}

func (fake *PeerOperations) InitChain(cid string) {
	fake.initChainMutex.Lock()
	fake.initChainArgsForCall = append(fake.initChainArgsForCall, struct {
		cid string
	}{cid})
	fake.recordInvocation("InitChain", []interface{}{cid})
	fake.initChainMutex.Unlock()
	if fake.InitChainStub != nil {
		fake.InitChainStub(cid)
	}
}

func (fake *PeerOperations) InitChainCallCount() int {
	fake.initChainMutex.RLock()
	defer fake.initChainMutex.RUnlock()
	return len(fake.initChainArgsForCall)
}

func (fake *PeerOperations) InitChainArgsForCall(i int) string {
	fake.initChainMutex.RLock()
	defer fake.initChainMutex.RUnlock()
	return fake.initChainArgsForCall[i].cid
}

func (fake *PeerOperations) Initialize(init func(string), sccp sysccprovider.SystemChaincodeProvider, pm plugin.Mapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider, lr plugindispatcher.LifecycleResources, nr plugindispatcher.LifecycleResources) {
	fake.initializeMutex.Lock()
	fake.initializeArgsForCall = append(fake.initializeArgsForCall, struct {
		init                   func(string)
		sccp                   sysccprovider.SystemChaincodeProvider
		pm                     plugin.Mapper
		pr                     *platforms.Registry
		deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider
		membershipProvider     ledger.MembershipInfoProvider
		metricsProvider        metrics.Provider
		lr                     plugindispatcher.LifecycleResources
		nr                     plugindispatcher.LifecycleResources
	}{init, sccp, pm, pr, deployedCCInfoProvider, membershipProvider, metricsProvider, lr, nr})
	fake.recordInvocation("Initialize", []interface{}{init, sccp, pm, pr, deployedCCInfoProvider, membershipProvider, metricsProvider, lr, nr})
	fake.initializeMutex.Unlock()
	if fake.InitializeStub != nil {
		fake.InitializeStub(init, sccp, pm, pr, deployedCCInfoProvider, membershipProvider, metricsProvider, lr, nr)
	}
}

func (fake *PeerOperations) InitializeCallCount() int {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return len(fake.initializeArgsForCall)
}

func (fake *PeerOperations) InitializeArgsForCall(i int) (func(string), sysccprovider.SystemChaincodeProvider, plugin.Mapper, *platforms.Registry, ledger.DeployedChaincodeInfoProvider, ledger.MembershipInfoProvider, metrics.Provider, plugindispatcher.LifecycleResources, plugindispatcher.LifecycleResources) {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return fake.initializeArgsForCall[i].init, fake.initializeArgsForCall[i].sccp, fake.initializeArgsForCall[i].pm, fake.initializeArgsForCall[i].pr, fake.initializeArgsForCall[i].deployedCCInfoProvider, fake.initializeArgsForCall[i].membershipProvider, fake.initializeArgsForCall[i].metricsProvider, fake.initializeArgsForCall[i].lr, fake.initializeArgsForCall[i].nr
}

func (fake *PeerOperations) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createChainFromBlockMutex.RLock()
	defer fake.createChainFromBlockMutex.RUnlock()
	fake.getChannelConfigMutex.RLock()
	defer fake.getChannelConfigMutex.RUnlock()
	fake.getChannelsInfoMutex.RLock()
	defer fake.getChannelsInfoMutex.RUnlock()
	fake.getStableChannelConfigMutex.RLock()
	defer fake.getStableChannelConfigMutex.RUnlock()
	fake.getCurrConfigBlockMutex.RLock()
	defer fake.getCurrConfigBlockMutex.RUnlock()
	fake.getLedgerMutex.RLock()
	defer fake.getLedgerMutex.RUnlock()
	fake.getMSPIDsMutex.RLock()
	defer fake.getMSPIDsMutex.RUnlock()
	fake.getPolicyManagerMutex.RLock()
	defer fake.getPolicyManagerMutex.RUnlock()
	fake.initChainMutex.RLock()
	defer fake.initChainMutex.RUnlock()
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *PeerOperations) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
